/**
* iRODS Query API
* This is the iRODS Query API
*
* OpenAPI spec version: 1.0.0
* Contact: info@irods.org
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/

#include "QueryApiImpl.h"
#include <memory>
#include <iostream>
#include "irods_query.hpp"
#include "boost/format.hpp"
#include "json.hpp"

static bool url_decode(const std::string& in, std::string& out)
{
    out.clear();
    out.reserve(in.size());
    for (std::size_t i = 0; i < in.size(); ++i)
    {
        if (in[i] == '%')
        {
            if (i + 3 <= in.size())
            {
                int value = 0;
                std::istringstream is(in.substr(i + 1, 2));
                if (is >> std::hex >> value)
                {
                    out += static_cast<char>(value);
                    i += 2;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else if (in[i] == '+')
        {
            out += ' ';
        }
        else
        {
            out += in[i];
        }
    }
    return true;
}

namespace io {
namespace swagger {
namespace server {
namespace api {

using namespace io::swagger::server::model;

QueryApiImpl::QueryApiImpl(Pistache::Address addr)
    : QueryApi(addr)
    {
        rodsEnv env{};
        _getRodsEnv(env);
        connection_pool_ = std::make_shared<irods::connection_pool>(
            1,
            env.rodsHost,
            env.rodsPort,
            env.rodsUserName,
            env.rodsZone,
            env.irodsConnectionPoolRefreshTime);

    }

void QueryApiImpl::catalog_query(
        const Pistache::Optional<std::string> &queryString,
        const Pistache::Optional<std::string> &queryLimit,
        const Pistache::Optional<std::string> &rowOffset,
        const Pistache::Optional<std::string> &queryType,
        Pistache::Http::ResponseWriter &response) {
    auto conn = connection_pool_->get_connection();
    std::string query_string;
    if(url_decode(queryString.get(), query_string)) {
        uintmax_t row_offset  = std::stoi(rowOffset.get());
        uintmax_t query_limit = std::stoi(queryLimit.get());
        auto query_type  = irods::query<rcComm_t>::convert_string_to_query_type(queryType.get());
        irods::query<rcComm_t> qobj{&static_cast<rcComm_t&>(conn), query_string, query_limit, row_offset, query_type};

        nlohmann::json results = nlohmann::json::object();
        nlohmann::json arrays = nlohmann::json::array();
        for(auto row : qobj) {
            nlohmann::json array = nlohmann::json::array();
            for(auto e : row) {
                array += e;
            }

            arrays += array;
        }
        results["results"] = arrays;
        response.send(Pistache::Http::Code::Ok, results.dump());
    }
    else {
        response.send(Pistache::Http::Code::Ok, "something has gone terribly wrong\n");
    }


}

}
}
}
}

