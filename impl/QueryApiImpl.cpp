/**
* iRODS Query API
* This is the iRODS Query API
*
* OpenAPI spec version: 1.0.0
* Contact: info@irods.org
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/

#include "QueryApiImpl.h"
#include <memory>
#include <iostream>
#include "irods_query.hpp"
#include "connection_pool.hpp"
#include "boost/format.hpp"
#include "json.hpp"

static bool url_decode(const std::string& in, std::string& out)
{
    out.clear();
    out.reserve(in.size());
    for (std::size_t i = 0; i < in.size(); ++i)
    {
        if (in[i] == '%')
        {
            if (i + 3 <= in.size())
            {
                int value = 0;
                std::istringstream is(in.substr(i + 1, 2));
                if (is >> std::hex >> value)
                {
                    out += static_cast<char>(value);
                    i += 2;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else if (in[i] == '+')
        {
            out += ' ';
        }
        else
        {
            out += in[i];
        }
    }
    return true;
}

namespace io {
namespace swagger {
namespace server {
namespace api {

using namespace io::swagger::server::model;

QueryApiImpl::QueryApiImpl(Pistache::Address addr)
    : QueryApi(addr)
    { }

void QueryApiImpl::catalog_query(const Pistache::Optional<std::string> &queryString, const Pistache::Optional<std::string> &rowOffset, const Pistache::Optional<std::string> &queryLimit, Pistache::Http::ResponseWriter &response) {
    rodsEnv env{};
    _getRodsEnv(env);
    auto tmp_pool = std::make_shared<irods::connection_pool>(
            1,
            env.rodsHost,
            env.rodsPort,
            env.rodsUserName,
            env.rodsZone,
            env.irodsConnectionPoolRefreshTime);
    auto conn = tmp_pool->get_connection();

    std::string query_string;
    if(url_decode(queryString.get(), query_string)) {
        uint32_t row_offset = std::stoi(rowOffset.get());
        uint32_t query_limit = std::stoi(queryLimit.get());

        irods::query<rcComm_t> qobj{&static_cast<rcComm_t&>(conn), query_string, query_limit, row_offset};

        nlohmann::json results = nlohmann::json::object();
        nlohmann::json arrays = nlohmann::json::array();
        for(auto row : qobj) {
            nlohmann::json array = nlohmann::json::array();
            for(auto e : row) {
                array += e;
            }

            arrays += array;
        }
        results["results"] = arrays;
        response.send(Pistache::Http::Code::Ok, results.dump());
    }
    else {
        response.send(Pistache::Http::Code::Ok, "something has gone terribly wrong\n");
    }


}

}
}
}
}

